"use strict";(self.webpackChunkzfile_docs=self.webpackChunkzfile_docs||[]).push([[808],{6712:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var t=s(7624),i=s(2172);const o={id:"ipsec-network",title:"IPsec Cross-cluster Network"},r="IPsec Cross-cluster container network solution",l={id:"v0.2.0/tutorials/ipsec-network",title:"IPsec Cross-cluster Network",description:"Using IPsec Tunnels for Cross-Cluster Container Network Communication over Public IP",source:"@site/docs/v0.2.0/tutorials/ccn-ipsec-tunnel.md",sourceDirName:"v0.2.0/tutorials",slug:"/v0.2.0/tutorials/ipsec-network",permalink:"/website/v0.2.0/tutorials/ipsec-network",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/v0.2.0/tutorials/ccn-ipsec-tunnel.md",tags:[],version:"current",frontMatter:{id:"ipsec-network",title:"IPsec Cross-cluster Network"},sidebar:"tutorialSidebar",previous:{title:"Kosmos Node NotReady",permalink:"/website/v0.2.0/tutorials/node-not-ready"},next:{title:"Kubernetes in Kubernetes",permalink:"/website/v0.2.0/proposals/k8s-in-k8s"}},c={},d=[{value:"Using IPsec Tunnels for Cross-Cluster Container Network Communication over Public IP",id:"using-ipsec-tunnels-for-cross-cluster-container-network-communication-over-public-ip",level:2},{value:"Introduction",id:"introduction",level:3},{value:"Motivation",id:"motivation",level:3},{value:"Goals",id:"goals",level:3},{value:"Design Details",id:"design-details",level:2},{value:"API Changes",id:"api-changes",level:3},{value:"Cluster API Changes",id:"cluster-api-changes",level:4},{value:"Clusternode API Changes",id:"clusternode-api-changes",level:4},{value:"Nodeconfig API Changes",id:"nodeconfig-api-changes",level:4},{value:"Component Modifications",id:"component-modifications",level:3},{value:"Clusterlink-controller-manager",id:"clusterlink-controller-manager",level:4},{value:"Clusterlink-elector",id:"clusterlink-elector",level:4},{value:"Clusterlink-network-manager",id:"clusterlink-network-manager",level:4},{value:"clusterlink-agent",id:"clusterlink-agent",level:4},{value:"kosmosctl",id:"kosmosctl",level:4}];function a(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.M)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"ipsec-cross-cluster-container-network-solution",children:"IPsec Cross-cluster container network solution"}),"\n",(0,t.jsx)(n.h2,{id:"using-ipsec-tunnels-for-cross-cluster-container-network-communication-over-public-ip",children:"Using IPsec Tunnels for Cross-Cluster Container Network Communication over Public IP"}),"\n",(0,t.jsx)(n.h3,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Kosmos is a multi-cluster solution, and networking is an essential part of it.\r\nSometimes, there is a need for communication between Kubernetes clusters in different networks.\r\nIn some cases, two or more clusters can only communicate with each other over the public internet.\r\nTo address this, Kosmos has implemented a cross-cluster container network communication solution based on IPsec tunnels."}),"\n",(0,t.jsx)(n.h3,{id:"motivation",children:"Motivation"}),"\n",(0,t.jsxs)(n.p,{children:["For the sake of disaster recovery, application deployments may require communication across different clouds or across regions within a single cloud (across VPCs).\r\nIn such scenarios, container communication becomes challenging as the internal IP addresses of the machines are usually not directly accessible without a dedicated network connection.\r\nCommon CNI tunnel technologies like ",(0,t.jsx)(n.code,{children:"VxLAN"})," or ",(0,t.jsx)(n.code,{children:"IPIP"})," may not work effectively in public internet environments.\r\nTo solve this problem, Kosmos has implemented a container network communication solution based on IPsec tunnels for cross-cloud communication over the public internet.\r\nThis solution addresses the need for communication across public networks while also considering data transmission security."]}),"\n",(0,t.jsx)(n.h3,{id:"goals",children:"Goals"}),"\n",(0,t.jsx)(n.p,{children:"The goal is to enable communication between pods in two clusters using elastic public IP addresses. The flow of traffic is illustrated in the diagram below:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"IPsec_Tunnel",src:s(563).c+"",width:"1301",height:"331"})}),"\n",(0,t.jsx)(n.admonition,{title:"NOTE",type:"info",children:(0,t.jsx)(n.p,{children:"This solution does not address container network communication in host network mode within a cluster.\r\nOnly focuses on IPv4 container network communication and does not cover IPv6 container networks."})}),"\n",(0,t.jsx)(n.h2,{id:"design-details",children:"Design Details"}),"\n",(0,t.jsx)(n.h3,{id:"api-changes",children:"API Changes"}),"\n",(0,t.jsx)(n.h4,{id:"cluster-api-changes",children:"Cluster API Changes"}),"\n",(0,t.jsxs)(n.p,{children:["This solution adds three fields to the ",(0,t.jsx)(n.code,{children:".spec.ClusterLinkOptions"}),": ",(0,t.jsx)(n.code,{children:"NodeElasticIPMap"}),", ",(0,t.jsx)(n.code,{children:"ClusterPodCIDRs"}),", and ",(0,t.jsx)(n.code,{children:"UseExternalApiserver"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",metastring:"script",children:'type ClusterLinkOptions struct {\r\n    ...\r\n    // NodeElasticIPMap presents mapping between nodename in kubernetes and elasticIP\r\n    // +optional\r\n    NodeElasticIPMap map[string]string `json:"nodeElasticIPMap,omitempty"`\r\n    // +optional\r\n    ClusterPodCIDRs []string `json:"clusterpodCIDRs,omitempty"`\r\n    // +optional\r\n    UseExternalApiserver bool `json:"useexternalapiserver,omitempty"`\r\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"NodeElasticIPMap"})," field represents the mapping relationship between the NodeName in Kubernetes and the elastic public IP mounted on the node."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ClusterPodCIDRs"})," field is added to input the Pod CIDR, as it is not always easy to obtain the Pod CIDR for some CNI plugins."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Typically, Kosmos retrieves the service CIDR through the kube-apiserver parameters. However, in some cases, the kube-apiserver is not a pod within the cluster. Therefore, the ",(0,t.jsx)(n.code,{children:"UseExternalApiserver"})," field is added to handle this scenario."]}),"\n",(0,t.jsx)(n.h4,{id:"clusternode-api-changes",children:"Clusternode API Changes"}),"\n",(0,t.jsxs)(n.p,{children:["This solution adds a new field, ",(0,t.jsx)(n.code,{children:"ElasticIP"}),", to the ",(0,t.jsx)(n.code,{children:".spec"}),", and a new field, ",(0,t.jsx)(n.code,{children:"NodeStatus"}),", to the ",(0,t.jsx)(n.code,{children:".status"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",metastring:"script",children:'type ClusterNodeSpec struct {\r\n    ...\r\n    // +optional\r\n    ElasticIP string `json:"elasticip,omitempty"`\r\n}\r\n\r\ntype ClusterNodeStatus struct {\r\n    // +optional\r\n    NodeStatus string `json:"nodeStatus,omitempty"`\r\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ElasticIP"})," field describes the elastic public IP mounted on the node."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"NodeStatus"}),' field describes the status of the node, either "Ready" or "NotReady".']}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"nodeconfig-api-changes",children:"Nodeconfig API Changes"}),"\n",(0,t.jsxs)(n.p,{children:["This solution adds two new fields, ",(0,t.jsx)(n.code,{children:"XfrmPoliciesXfrmStates"})," and ",(0,t.jsx)(n.code,{children:"IPsetsAvoidMasqs"}),", to the ",(0,t.jsx)(n.code,{children:".spec"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",metastring:"script",children:'type NodeConfigSpec struct {\r\n    XfrmPolicies     []XfrmPolicy `json:"xfrmpolicies,omitempty"`\r\n    XfrmStates       []XfrmState  `json:"xfrmstates,omitempty"`\r\n    IPsetsAvoidMasqs []IPset      `json:"ipsetsavoidmasq,omitempty"`\r\n}\r\n\r\ntype XfrmPolicy struct {\r\n    LeftIP   string `json:"leftip"`\r\n    LeftNet  string `json:"leftnet"`\r\n    RightIP  string `json:"rightip"`\r\n    RightNet string `json:"rightnet"`\r\n    ReqID    int    `json:"reqid"`\r\n    Dir      int    `json:"dir"`\r\n}\r\n\r\ntype XfrmState struct {\r\n    LeftIP  string `json:"leftip"`\r\n    RightIP string `json:"rightip"`\r\n    ReqID   int    `json:"reqid"`\r\n    SPI     uint32 `json:"spi"`\r\n    PSK     string `json:"PSK"`\r\n}\r\n\r\ntype IPset struct {\r\n    CIDR string `json:"cidr"`\r\n    Name string `json:"name"`\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The new ",(0,t.jsx)(n.code,{children:"XfrmPolicies"})," and ",(0,t.jsx)(n.code,{children:"XfrmStates"})," fields define the IPsec-related rules created by Kosmos."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"IPsetsAvoidMasqs"})," field describes the network segments that need to avoid masquerading, allowing outbound traffic from containers to retain their container IP address."]}),"\n",(0,t.jsx)(n.h3,{id:"component-modifications",children:"Component Modifications"}),"\n",(0,t.jsx)(n.h4,{id:"clusterlink-controller-manager",children:"Clusterlink-controller-manager"}),"\n",(0,t.jsx)(n.p,{children:"Handling scenarios where kube-apiserver pods are not within the cluster:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The cluster-controller optimizes the retrieval of service CIDR through the ",(0,t.jsx)(n.code,{children:"GetSvcByCreateInvalidSvc"})," function."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Node status synchronization:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The node-controller synchronizes the ",(0,t.jsx)(n.code,{children:"ElasticIP"})," field of the ",(0,t.jsx)(n.code,{children:"clusternode"})," object based on the values in the ",(0,t.jsx)(n.code,{children:"NodeElasticIPMap"})," field of the ",(0,t.jsx)(n.code,{children:"cluster"})," object."]}),"\n",(0,t.jsxs)(n.li,{children:["The node-controller now updates the ",(0,t.jsx)(n.code,{children:".Status.NodeStatus"})," field of the ",(0,t.jsx)(n.code,{children:"clusternode"}),' object based on the node\'s status, "Ready" or "NotReady".']}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"clusterlink-elector",children:"Clusterlink-elector"}),"\n",(0,t.jsxs)(n.p,{children:["The elector module is used for ",(0,t.jsx)(n.code,{children:"Gateway"})," selection in Gateway mode. It can now select a ",(0,t.jsx)(n.code,{children:"Gateway"}),' from the nodes in "Ready" state.']}),"\n",(0,t.jsx)(n.h4,{id:"clusterlink-network-manager",children:"Clusterlink-network-manager"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Adding support for some CNI plugins\r\nFor some CNI plugins, iptables rules are added to avoid masquerading, allowing outbound traffic from containers to retain their container IP address."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Building IPsec rules\r\nTypically, Kosmos creates routes to achieve container communication. In IPsec tunnel mode, Kosmos creates ",(0,t.jsx)(n.code,{children:"ip xfrm state"})," and ",(0,t.jsx)(n.code,{children:"ip xfrm policy"})," rules if the ",(0,t.jsx)(n.code,{children:"ElasticIP"})," field of the ",(0,t.jsx)(n.code,{children:"clusternode"})," is not empty."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"clusterlink-agent",children:"clusterlink-agent"}),"\n",(0,t.jsxs)(n.p,{children:["Functions have been added to execute specific operations, equivalent to executing ",(0,t.jsx)(n.code,{children:"ip xfrm state add/del"})," and ",(0,t.jsx)(n.code,{children:"ip xfrm policy add/del"})," commands on the operating system."]}),"\n",(0,t.jsxs)(n.p,{children:["To avoid masquerading, functions have been added to execute ",(0,t.jsx)(n.code,{children:"ipset"})," commands and create iptables rules."]}),"\n",(0,t.jsx)(n.h4,{id:"kosmosctl",children:"kosmosctl"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"NodeElasticIP"}),", ",(0,t.jsx)(n.code,{children:"UseExternalApiserver"}),", and ",(0,t.jsx)(n.code,{children:"ClusterPodCIDRs"})," input parameters have been added to populate the new fields ",(0,t.jsx)(n.code,{children:"NodeElasticIPMap"}),", ",(0,t.jsx)(n.code,{children:"UseExternalApiserver"}),", and ",(0,t.jsx)(n.code,{children:"ClusterPodCIDRs"})," in the ",(0,t.jsx)(n.code,{children:"Cluster"})," CRD."]})]})}function u(e={}){const{wrapper:n}={...(0,i.M)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},563:(e,n,s)=>{s.d(n,{c:()=>t});const t=s.p+"assets/images/IPsec_Tunnel-9f261fc88ef5a03937ab257a45539388.jpeg"},2172:(e,n,s)=>{s.d(n,{I:()=>l,M:()=>r});var t=s(1504);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);